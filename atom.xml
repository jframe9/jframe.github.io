<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jfchen&#39;s blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.chenjf.cf/"/>
  <updated>2019-11-22T02:10:16.835Z</updated>
  <id>http://blog.chenjf.cf/</id>
  
  <author>
    <name>Jfchen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>亚马逊机器翻译框架-训练说明文档(0)</title>
    <link href="http://blog.chenjf.cf/2019/11/22/%E4%BA%9A%E9%A9%AC%E9%80%8A%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E6%A1%86%E6%9E%B6-%E8%AE%AD%E7%BB%83%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3-3/"/>
    <id>http://blog.chenjf.cf/2019/11/22/%E4%BA%9A%E9%A9%AC%E9%80%8A%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E6%A1%86%E6%9E%B6-%E8%AE%AD%E7%BB%83%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3-3/</id>
    <published>2019-11-22T01:27:10.000Z</published>
    <updated>2019-11-22T02:10:16.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Setup-amp-Installation"><a href="#Setup-amp-Installation" class="headerlink" title="Setup &amp; Installation"></a>Setup &amp; Installation</h3><h4 id="依存关系"><a href="#依存关系" class="headerlink" title="依存关系"></a>依存关系</h4><p><code>Sockeye</code>所需要的环境：</p><ul><li><strong>Python3</strong></li><li>MXNet</li><li>numpy</li></ul><h4 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h4><p>下面有几个有关<code>Sockeye</code>和他的依存关系安装选项。下面我们会罗列出几个备选方案，和一些相关的说明。</p><a id="more"></a><p>-&gt; <strong>via pip</strong></p><p>最简单的方式是使用pip:</p><blockquote><p>pip install sockeye</p></blockquote><p>如果你想在GPU上运行sockeye，你需要确保你的Apache MXNet孵化版本包含了GPU绑定。根据你的CUDA版本，你可以运行以下命令:</p><blockquote><p> wget <a href="https://raw.githubusercontent.com/awslabs/sockeye/master/requirements/requirements.gpu-cu${CUDA_VERSION}.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/awslabs/sockeye/master/requirements/requirements.gpu-cu${CUDA_VERSION}.txt</a></p><p>pip install sockeye –no-deps -r requirements.gpu-cu${CUDA_VERSION}.txt</p><p>rm requirements.gpu-cu${CUDA_VERSION}.txt</p></blockquote><p>其中，<strong>${CUDA_VERSION}</strong>可以被写成80(8.0)，90 (9.0), 92 (9.2), or 100 (10.0).分别对应的是CUDA的版本。</p><p>-&gt; <strong>via source…</strong></p><p>如果你只想使用sockeye而不扩展它，只需通过安装它即可：</p><blockquote><p>pip install -r requirements/requirements.txt</p><p>pip install .</p></blockquote><p>从github的仓库中克隆过来以后。</p><p>如果你想在GPU上运行sockeye，你需要确保你的Apache MXNet孵化版本包含了GPU绑定。根据你的CUDA版本，你可以运行以下命令:</p><blockquote><p>pip install -r requirements/requirements.gpu-cu${CUDA_VERSION}.txt</p><p>pip install .</p></blockquote><p>其中，<strong>${CUDA_VERSION}</strong>可以被写成80(8.0)，90 (9.0), 92 (9.2), or 100 (10.0).分别对应的是CUDA的版本。</p><p>开发人员最好将<code>$PYTHONPATH</code>指向git克隆源的根目录。</p><p>-&gt; 利用anaconda环境，其中，<code>anaconda</code>包含了conda、Python等180个多个科学包及依赖项。用户只需要运行以下行来安装sockeye(在一个没有GPU的实例上):</p><blockquote><p>conda create -n sockeye python=3.6 // 创建一个虚拟环境 sockeye</p><p>source activate sockeye     //激活环境</p><p>pip install sockeye –no-deps  //安装sockeye</p></blockquote><p>在使用GPU的实例上，下面的命令如下执行：</p><blockquote><p>conda create -n sockeye python=3.6</p><p>source activate sockeye</p><p>wget <a href="https://raw.githubusercontent.com/awslabs/sockeye/master/requirements/requirements.gpu-cu${CUDA_VERSION}.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/awslabs/sockeye/master/requirements/requirements.gpu-cu${CUDA_VERSION}.txt</a></p><p>pip install sockeye –no-deps -r requirements.gpu-cu${CUDA_VERSION}.txt</p><p>rm requirements.gpu-cu${CUDA_VERSION}.txt</p></blockquote><p>其中，<strong>${CUDA_VERSION}</strong>可以被写成80(8.0)，90 (9.0), 92 (9.2), or 100 (10.0).分别对应的是CUDA的版本。</p><h4 id="可选择的依赖关系"><a href="#可选择的依赖关系" class="headerlink" title="可选择的依赖关系"></a>可选择的依赖关系</h4><p>你可以安装Tensorboard来对训练过程可视化，您可以选择安装mxboard（<code>pip install mxboard</code>）。为了可视化过程，运行Tensorboard工具（<code>pip install tensorboard tensorflow</code>）日志目录指向训练输出文件夹：<code>tensorboard --logdir &lt;model&gt;</code>。</p><p>如果要创建对齐图，需要安装matplotlib（pip install matplotlib）。</p><h4 id="Running-sockeye"><a href="#Running-sockeye" class="headerlink" title="Running sockeye"></a>Running sockeye</h4><p>安装之后，可以使用诸如sockeye-train、sockeye-translate、sockeye-average和sockeye-embeddings之类的命令行工具。下面举例：</p><blockquote><p>sockeye-train <args></p></blockquote><p>同样，如果sockeye目录在$PYTHONPATH上，则可以直接运行模块:</p><blockquote><p>python -m sockeye.train <args></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Setup-amp-Installation&quot;&gt;&lt;a href=&quot;#Setup-amp-Installation&quot; class=&quot;headerlink&quot; title=&quot;Setup &amp;amp; Installation&quot;&gt;&lt;/a&gt;Setup &amp;amp; Installation&lt;/h3&gt;&lt;h4 id=&quot;依存关系&quot;&gt;&lt;a href=&quot;#依存关系&quot; class=&quot;headerlink&quot; title=&quot;依存关系&quot;&gt;&lt;/a&gt;依存关系&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Sockeye&lt;/code&gt;所需要的环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Python3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MXNet&lt;/li&gt;
&lt;li&gt;numpy&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Installation&quot;&gt;&lt;a href=&quot;#Installation&quot; class=&quot;headerlink&quot; title=&quot;Installation&quot;&gt;&lt;/a&gt;Installation&lt;/h4&gt;&lt;p&gt;下面有几个有关&lt;code&gt;Sockeye&lt;/code&gt;和他的依存关系安装选项。下面我们会罗列出几个备选方案，和一些相关的说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器翻译" scheme="http://blog.chenjf.cf/categories/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="AI" scheme="http://blog.chenjf.cf/tags/AI/"/>
    
      <category term="machine translate" scheme="http://blog.chenjf.cf/tags/machine-translate/"/>
    
  </entry>
  
  <entry>
    <title>亚马逊机器翻译框架-训练说明文档(2)</title>
    <link href="http://blog.chenjf.cf/2019/11/20/%E4%BA%9A%E9%A9%AC%E9%80%8A%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E6%A1%86%E6%9E%B6-%E8%AE%AD%E7%BB%83%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3-2/"/>
    <id>http://blog.chenjf.cf/2019/11/20/%E4%BA%9A%E9%A9%AC%E9%80%8A%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E6%A1%86%E6%9E%B6-%E8%AE%AD%E7%BB%83%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3-2/</id>
    <published>2019-11-20T06:41:30.000Z</published>
    <updated>2019-11-22T02:10:07.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>解码过程的实现，主要是通过<code>sockeye.translate</code>模块。</p><a id="more"></a><blockquote><p>python -m sockeye.translate</p></blockquote><p>这一步仅仅需要一个<code>--models</code>参数，它指向的是训练模型<code>&lt;model_dir&gt;</code>文件夹路径。<code>sockeye</code>默认从最好的<code>checkpoints</code>参数，并且使用他们来做翻译。你可以指定特定的参数从特定的<code>checkpoint</code>中，使用的指令是<code>--checkpoints X</code>。</p><p>你可以使用<code>--beam-size</code>控制beam尺寸的大小，通过<code>--max-input-length</code>控制输入的最大长度。一旦序列长度超过最大长度，就会被忽略。</p><p>从标准输入读取输入，然后将输出写入标准输出。一旦使用了输入，<code>CLI</code>将记录转换速度。和训练过程一样，第一块GPU是默认使用的。需要注意的是多GPU目前还不支持。需要使用CPU，请用<code>--use-cpu</code>。</p><p>使用<code>--help</code>选线，查看完整列表选项。</p><h5 id="整体解码"><a href="#整体解码" class="headerlink" title="整体解码"></a>整体解码</h5><p>Sockeye通过指定多个模型目录和多个检查点来支持集成解码。列表必须有相同的长度，这样，第一个给定的检查点将从第一个模型目录中获取，从第二个目录中指定的第二个检查点，等等。</p><blockquote><p> python -m sockeye.translate –models [<m1prefix> <m2prefix>] –checkpoints [<cp1> <cp2>]</p></blockquote><h5 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h5><p>转换CLI的默认模式是将转换输出到STDOUT。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Translation&quot;&gt;&lt;a href=&quot;#Translation&quot; class=&quot;headerlink&quot; title=&quot;Translation&quot;&gt;&lt;/a&gt;Translation&lt;/h3&gt;&lt;p&gt;解码过程的实现，主要是通过&lt;code&gt;sockeye.translate&lt;/code&gt;模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器翻译" scheme="http://blog.chenjf.cf/categories/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="AI" scheme="http://blog.chenjf.cf/tags/AI/"/>
    
      <category term="machine translate" scheme="http://blog.chenjf.cf/tags/machine-translate/"/>
    
  </entry>
  
  <entry>
    <title>亚马逊机器翻译框架-训练说明文档(1)</title>
    <link href="http://blog.chenjf.cf/2019/11/19/%E4%BA%9A%E9%A9%AC%E9%80%8A%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E6%A1%86%E6%9E%B6-%E8%AE%AD%E7%BB%83%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"/>
    <id>http://blog.chenjf.cf/2019/11/19/%E4%BA%9A%E9%A9%AC%E9%80%8A%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E6%A1%86%E6%9E%B6-%E8%AE%AD%E7%BB%83%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</id>
    <published>2019-11-19T13:09:16.000Z</published>
    <updated>2019-11-21T13:29:16.590Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>英文版本地址：<a href="https://awslabs.github.io/sockeye/training.html" target="_blank" rel="noopener">https://awslabs.github.io/sockeye/training.html</a></p></blockquote><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><center><p>   <img src="/images/photo/dockeye.png" alt="dockeye"></p></center><a id="more"></a><h4 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h4><p><code>Sockeye</code>在训练时间可以凭借<code>--source</code> 以及<code>--target</code>命令行，按行来读取平行语料中的数据。您还可以提前准备数据并将其作为<code>MXNet NDArrays</code>格式转储到磁盘。这基本上消除了运行训练时的数据加载时间(因为需要三次传递原始数据)，也能减少内存消耗，<strong>因为准备好的数据也被放入随机的碎片中</strong>（默认情况下每行有100万行）。运行数据表示，你可以按照下面的命令：</p><p>对应文件是：<strong>prepare_data.py</strong></p><blockquote><p>python -m sockeye.prepare_data</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;usage:  prepare_data.py  [-h] --source SOURCE</span><br><span class="line">                 [--source-factors SOURCE_FACTORS [SOURCE_FACTORS ...]]</span><br><span class="line">                 --target TARGET [--source-vocab SOURCE_VOCAB]</span><br><span class="line">                    [--target-vocab TARGET_VOCAB]</span><br><span class="line">                    [--source-factor-vocabs SOURCE_FACTOR_VOCABS [SOURCE_FACTOR_VOCABS ...]]</span><br><span class="line">                    [--shared-vocab] [--num-words NUM_WORDS]</span><br><span class="line">                    [--word-min-count WORD_MIN_COUNT]</span><br><span class="line">                    [--pad-vocab-to-multiple-of PAD_VOCAB_TO_MULTIPLE_OF]</span><br><span class="line">                    [--no-bucketing] [--bucket-width BUCKET_WIDTH]</span><br><span class="line">                    [--max-seq-len MAX_SEQ_LEN]</span><br><span class="line">                    [--num-samples-per-shard NUM_SAMPLES_PER_SHARD]</span><br><span class="line">                    [--min-num-shards MIN_NUM_SHARDS] [--seed SEED]</span><br><span class="line">                    --output OUTPUT</span><br><span class="line">   prepare_data.py: error: the following arguments are required: --source/-s, --target/-t, --output/-o</span><br></pre></td></tr></table></figure></blockquote><p>最重要的参数是上面所需要的（<code>--source</code>, <code>--target</code>, <code>--output</code>将确定预处理文件的写入路径。）</p><ul><li>其他比较重要的参数：<ul><li><code>--shared-vocab</code>: 在语料库的源方和目标方之间产生一个共享的词汇表。</li><li><code>--num-samples-per-shard</code>: 控制共享尺寸。</li></ul></li></ul><p>在训练时间（下一节），用指定的预训练数据来代替源数据和目标数据。</p><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>训练是通过<code>sockeye.train</code>这个模块。基础的用法，下面将会给出：</p><p>对应文件：<strong>train.py</strong></p><blockquote><p>python -m sockeye.train</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usage: train.py [-h]</span><br><span class="line">--source SOURCE       --target TARGET </span><br><span class="line">--validation-source VALIDATION_SOURCE   --validation-target VALIDATION_TARGET</span><br><span class="line">--output OUTPUT [...]</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>训练一共需要5个参数：</p><ul><li><code>--source</code>,<code>--target</code>:  需要提供训练所需要的文件。支持<code>Gzipped</code>文件，前提是它们的文件名以 <code>.gz</code>结尾</li><li><code>--validation-source</code>, <code>--validation-target</code>:  需要提供连个验证集；<code>gzip</code>文件也同上</li><li><code>--output</code>: 给出将写入中间结果和最终结果的输出路径。如果需要中间结果，也可以提供中间结果的输出路径。日志会被写入到模型所在目录的log文件夹内，并且输出。</li></ul><blockquote><p>注：如果想知道更多的参数，可以考虑选择<code>--help</code>，来寻求帮助。</p></blockquote></li></ul><h5 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h5><p>所有的输入文件应该是<strong>UTF-8</strong>编码的，用标准的<strong>空格</strong>来标记。每一行包含一个单独的序列，源文件和目标文件应该包含相同的行数，词汇表将根据训练数据自动创建，并将报告初始化期间验证集的词汇表覆盖率。</p><h5 id="Checkpointing-and-early-stopping"><a href="#Checkpointing-and-early-stopping" class="headerlink" title="Checkpointing and early-stopping"></a>Checkpointing and early-stopping</h5><p>训练是通过<code>Checkpoints</code>这个概念来管理，而不是<code>epoch</code>。你可以更新/批次<code>--checkpoint-interval</code>来指定检查点的间隔。提前结束训练过程可以有效的避免过拟合，例如：一旦对给定的参数设置的检查点的数量没有改善，那么在给定的验证数据上计算的评估指标就会停止训练<code>--max-num-checkpoint-not-improved</code>。你可以指定一个最大数目的更新/批次通过使用<code>--max-updates</code>。</p><p><code>Perplexity</code>是作为提早停止训练的默认标准，但是您也可以使用<code>--optimized-metric</code> 参数选择优化准确性或BLEU 。如果要针对BLEU进行优化，则需要指定 <code>--monitor-bleu</code>。出于效率原因，<code>sockeye</code>在每个检查点之后都生成一个子过程，以对验证数据进行解码并计算BLEU。这可能会在结果报告中引入一些延迟，即，可能包括一些<code>checkpoints</code>没有包括BLEU的结果报告，一些结果数据和以前的<code>checkpoints</code>对应。这是预期的行为，sockeye内部会按照正确的顺序跟踪结果。</p><p>请注意，训练数据和保留的验证数据的评估指标将写入一个名为的制表符分隔文件中<code>metrics</code>。</p><p>对于每一个<code>checkpoints</code>，训练过程的内部状态都存储到磁盘上。如果训练过程被中断（硬盘问题），你可以再开始<code>sockeye</code>进程，则可以使用与初始训练相同的参数再次启动<code>sockeye</code>，训练过程将会从最后一个<code>checkpoint</code>恢复。请注意，这与使用<code>--params</code>参数不同。此参数仅用于使用模型参数的预先计算的值来初始化训练，而优化器和系统其他部分的参数是从头开始初始化的。</p><h5 id="使用可视化工具监视训练过程"><a href="#使用可视化工具监视训练过程" class="headerlink" title="使用可视化工具监视训练过程"></a>使用可视化工具监视训练过程</h5><p><code>Sockeye</code>可以使用<code>Tensorboard</code>兼容格式编写所有评估指标。这样你就可以在浏览器中监控训练进程。要启用此功能，请安装与mxnet兼容的接口mxboard:</p><blockquote><p>pip install mxboard</p></blockquote><p>为了可视化，你仍然需要官方的tensorboard版本(即 pip install tensorboard)。启动tensorboard并将其指向模型目录(或任何父目录):</p><blockquote><p>tensorboard –logdir model_dir</p></blockquote><h5 id="CPU-GPU训练"><a href="#CPU-GPU训练" class="headerlink" title="CPU/GPU训练"></a>CPU/GPU训练</h5><p>训练过程默认的是在你自己设备中的第一块GPU设备上执行。你可以选择，指定特定的GPU设备，利用<code>--device-ids</code>指令，你也可以多个GPU来训练。如果指令为<code>--device-ids -1</code>这种情况，<code>sockeye</code>将尝试在你的机器上找到一个空闲的GPU并阻塞，直到有一个可用。锁定机制基于文件，因此假定所有进程都运行在具有相同文件系统的同一台机器上。如果不是这种情况，有可能两个进程将使用相同的GPU和你用完GPU内存。如果你<strong>没有或者不想使用GPU</strong>，指定<code>--use-cpu</code>。在这种情况下，预期性能会下降。</p><h5 id="多个GPU训练"><a href="#多个GPU训练" class="headerlink" title="多个GPU训练"></a>多个GPU训练</h5><p>你可以利用多块GPU，通过指定GPU设备的id:<code>--device-ids 0 1 2 3</code>，或者指定需要GPU的块数：<code>--device-ids -n</code> （尝试获取<strong>n块</strong>GPU，利用上述描述的锁定机制）。这将使用数据并行性进行训练。MXNet将会将数据切分成若干干批次，然后将他们输入到不同的GPU设备中。在这里需要注意的是：你应该增加批次的数量：for k GPU s use <code>--bach-size k*&lt;original_batch_size&gt;</code>.还要注意，这可能会以句子/秒为单位线性增加您的吞吐量，但不一定会增加模型的收敛速度。</p><h5 id="Checkpoint-averaging"><a href="#Checkpoint-averaging" class="headerlink" title="Checkpoint averaging"></a>Checkpoint averaging</h5><p>提高模型性能的一种常见技术是对最后一个检查点的权重进行平均。可以这样做:</p><blockquote><p>python -m sockeye.average <model_dir> -o <model_dir>/model.best.avg.params</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;英文版本地址：&lt;a href=&quot;https://awslabs.github.io/sockeye/training.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://awslabs.github.io/sockeye/training.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Training&quot;&gt;&lt;a href=&quot;#Training&quot; class=&quot;headerlink&quot; title=&quot;Training&quot;&gt;&lt;/a&gt;Training&lt;/h3&gt;&lt;center&gt;

&lt;p&gt;   &lt;img src=&quot;/images/photo/dockeye.png&quot; alt=&quot;dockeye&quot;&gt;&lt;/p&gt;
&lt;/center&gt;
    
    </summary>
    
    
      <category term="机器翻译" scheme="http://blog.chenjf.cf/categories/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="AI" scheme="http://blog.chenjf.cf/tags/AI/"/>
    
      <category term="machine translate" scheme="http://blog.chenjf.cf/tags/machine-translate/"/>
    
  </entry>
  
  <entry>
    <title>Conda 安装命令大全</title>
    <link href="http://blog.chenjf.cf/2019/11/18/Conda-%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://blog.chenjf.cf/2019/11/18/Conda-%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2019-11-18T10:33:48.000Z</published>
    <updated>2019-11-20T13:55:19.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux命令：经验总结"><a href="#Linux命令：经验总结" class="headerlink" title="Linux命令：经验总结"></a>Linux命令：经验总结</h2><h3 id="版本查看"><a href="#版本查看" class="headerlink" title="版本查看"></a>版本查看</h3><a id="more"></a><ol><li><p>cuda版本 查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/local/cuda/version.txt</span><br></pre></td></tr></table></figure></li><li><p>cudnn版本查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure></li></ol><p>tensorflow的版本需要和cuda版本一致，才可以使用。</p><h3 id="conda创建虚拟环境"><a href="#conda创建虚拟环境" class="headerlink" title="conda创建虚拟环境"></a>conda创建虚拟环境</h3><ol><li><p>创建一个名为jfchen的环境，指定python版本是3.6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name jfchen python=3.6</span><br></pre></td></tr></table></figure></li><li><p>查看创建的所有环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda list env  <span class="comment"># 指的是那些包</span></span><br><span class="line">conda info --envs <span class="comment"># 创建环境的名称</span></span><br></pre></td></tr></table></figure></li><li><p>激活与关闭虚拟环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source activate jfchen <span class="comment"># 激活环境</span></span><br><span class="line">source deactivate jfchen <span class="comment"># 关闭虚拟环境</span></span><br></pre></td></tr></table></figure></li><li><p>删除环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name jfchen --all</span><br></pre></td></tr></table></figure></li></ol><h4 id="安装tensorflow"><a href="#安装tensorflow" class="headerlink" title="安装tensorflow"></a>安装tensorflow</h4><ol><li><p>使用pip安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU版本</span></span><br><span class="line">pip install tensorflow==版本号</span><br><span class="line"></span><br><span class="line"><span class="comment"># GPU版本</span></span><br><span class="line">pip install tensorflow-gpu==版本号</span><br></pre></td></tr></table></figure></li></ol><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ol><li><p>用Vim打开并编辑 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>重启环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>查看已安装的环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure></li></ol><h4 id="退出xshell而进程不中断进程-screen命令"><a href="#退出xshell而进程不中断进程-screen命令" class="headerlink" title="退出xshell而进程不中断进程-screen命令"></a>退出xshell而进程不中断进程-screen命令</h4><ol><li><p>常见screen参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名叫jfchen的session</span></span><br><span class="line">screen -S jfchen </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前所有的session</span></span><br><span class="line">screen -ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到jfchen会话</span></span><br><span class="line">screen -r jfchen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程detach某个session</span></span><br><span class="line">screen -d jfchen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束当前session并回到jfchen这个session</span></span><br><span class="line">screen -d -r jfchen</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux命令：经验总结&quot;&gt;&lt;a href=&quot;#Linux命令：经验总结&quot; class=&quot;headerlink&quot; title=&quot;Linux命令：经验总结&quot;&gt;&lt;/a&gt;Linux命令：经验总结&lt;/h2&gt;&lt;h3 id=&quot;版本查看&quot;&gt;&lt;a href=&quot;#版本查看&quot; class=&quot;headerlink&quot; title=&quot;版本查看&quot;&gt;&lt;/a&gt;版本查看&lt;/h3&gt;
    
    </summary>
    
    
      <category term="指令" scheme="http://blog.chenjf.cf/categories/%E6%8C%87%E4%BB%A4/"/>
    
    
      <category term="conda" scheme="http://blog.chenjf.cf/tags/conda/"/>
    
      <category term="随笔" scheme="http://blog.chenjf.cf/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="linux" scheme="http://blog.chenjf.cf/tags/linux/"/>
    
  </entry>
  
</feed>
